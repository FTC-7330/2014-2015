#pragma config(Sensor, S1,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//tyler is better than rohan

float degHeading;
float initial;
float radHeading;
int lastTime = 0;
int initialGyroValue = 0;

task heading()
{
	ClearTimer(T1); // sets timer to 0

	while(true)
	{
		int currentVelocity = SensorValue[gyro] - initialGyroValue; // gets the new sensor reading
		nxtDisplayString(2, "Velocity: %d                      ", currentVelocity;
		degHeading += (currentVelocity) * (time1[T1] - lastTime) * .001; // modifies the header
		lastTime = time1[T1]; // sets the last time for the next reading
		if (time1[T1] > 30000) // this resets the timer after 30 seconds
		{
			ClearTimer(T1);
			lastTime = 0;
		}
		radheading = degHeading / 180 * PI; // the heading expressed in radians
		wait1Msec(10); // lets other tasks run
	}
}

float min(float a, float b)
{
	if (a < b)
		return a;
	else
		return b;
}

task main()
{
	int sum = 0;
	for (int i = 0; i < 100; i++) {
		sum += SensorValue[gyro];
		wait1Msec(1);
	}
	initialGyroValue = sum / 100;
	startTask(heading);
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = -100;
	while (true)
	{
		nxtDisplayString(1, "Degrees: %d                      ", degHeading);
		motor[motorA] = 5;
		motor[motorB] = 5;
	}
}
